# 해싱

- 해싱은 데이터를 단시간에 `삽입`하거나 저장된 데이터를 `가져올 때` 주로 사용하는 기법이다. 해싱은 `해시 테이블`이라는 자료구조를 이용한다. 해싱을 이용하면 데이터를 `빠르게 삽입하고, 삭제하고, 가져올 수 있지만`, 최솟값이나 최댓값 찾기 등 `검색 동작은 효율이 떨어진다`. 따라서 검색이 필요한 상황이라면 이진 탐색 트리 같은 자료구조를 사용하는 것이 좋다.

## 1. 해싱 개요

- 해시 테이블 자료구조는 배열을 이용한다.
  - `key`라 불리는 데이터 요소로 배열에 저장된 데이터 요소를 참조할 수 있다.
- 이론적으로 해시 함수는 각 키를 자체 배열 요소로 저장한다. 하지만 키의 개수에는 제한이 없지만, 자바스크립트의 배열 요소 수는 제한이 있으므로 되도록이면 키가 한 고에 집중되지 않도록 저장하는 것이 좋다.
- 두 키의 해시 결과(해시 함수 수행 결과)가 같은 값일 때, 이를 `충돌(collision)` 이라 한다.
- 해시 함수를 만들기 전에 최종적으로 해시 테이블에 사용할 배열의 크기를 결정해야 한다.
  - 보통 배열의 크기는 `소수`여야 한다.
- 충돌을 처리하는 기법도 배열의 크기에 영향을 미친다.

## 2. 해시 테이블 클래스

### 2-1. 해시 함수 선택하기

- 키의 데이터형에 따라 해시 함수가 달라진다.
  - [정수] 예를 들어 정수 키라면 배열의 크기로 나눈 나머지를 반환하는 해시 함수를 이용할 수 있다.
    - 하지만 키가 모두 0으로 끝나며 배열의 크기가 10인 상황에서는 이런 간단한 해시 함수도 사용할 수 없다. 앞에서 배열의 크기를 `소수`로 설정하는 이유도 이와 관련이 있다.
    - 키가 임의의 정수라면 해시 함수는 더 정확하게 키를 분산시켜야 한다. 이런 종류의 해싱을 `모듈러(modular) 해싱`이라 한다.
  - [문자열] 많은 애플리케이션에서 문자열을 키로 사용한다. 문자열 키와 관련한 해시 함수는 좀 더 복잡하므로 신중하게 선택해야 한다.
    - 문자열 해싱하는 방법 중 문자의 아스키 값을 더하는 함수가 있다. 최정적으로 합계를 배열의 크기로 나눈 나머지를 해시 값으로 반환한다.

```js
function HashTable() {
  this.table = new Array(137);
  this.simpleHash = simpleHash;
  this.showDistro = showDistro;
  this.put = put;
  //this.get = get;
}

function simpleHash(data) {
  let total = 0;
  for (let i = 0; i < data.length; ++i) {
    total += data.charCodeAt(i);
  }
  console.log('Hash value: ' + data + '->' + total);
  return total % this.table.length;
}

function put(data) {
  let pos = this.simpleHash(data);
  this.table[pos] = data;
}

function showDistro() {
  let n = 0;
  for (let i = 0; i < this.table.length; ++i) {
    if (this.table[i] != undefined) {
      console.log(i + ':' + this.table[i]);
    }
  }
}

let someNames = [
  'Raymond',
  'Clayton',
  'Marco',
  'Poky',
  'Jisoo',
  'Jinnie',
  'Millie',
  'Dotori',
];
let hTable = new HashTable();
for (let i = 0; i < someNames.length; ++i) {
  hTable.put(someNames[i]);
}

hTable.showDistro();
```

```
//output
Hash value: Raymond->730
Hash value: Clayton->730
Hash value: Marco->498
Hash value: Poky->419
Hash value: Jisoo->516
Hash value: Jinnie->605
Hash value: Millie->604
Hash value: Dotori->625
8:Poky
45:Clayton
56:Millie
57:Jinnie
77:Dotori
87:Marco
105:Jisoo
```

- 위 예제에서 해시 테이블에 저장된 값들이 균등하게 분포되지 않았음을 확인할 수 있다.
- 또한, 'Clayton'과 'Raymond'의 해시 값이 같아서 충돌이 일어났음을 확인할 수 있다. 충돌 때문에 'Clayton'만 배열에 저장됐다.

## 2-2. 더 좋은 해시 함수

- 우선 충돌을 피하려면 해시 테이블에서 사용하는 배열의 크기가 `소수`여야 한다.
  - 이는 해시 값을 계산할 때 `모듈로 연산` 을 사용하기 때문이다. 테이블에서 키가 균등하게 분포하도록 만들려면 배열의 크기가 100이상이어야 한다. 100보다 작은 소수를 선택하면 충돌이 더 잦아진다.
- 해시 테이블의 크기를 결정했으면 해싱 충돌을 회피할 수 있는 해시 값 계산 방법을 만들어야 한다. `호너의 메소드` 라는 알고리즘을 이용하여 문자열의 아스키 값을 더하는 기법을 개선할 수 있다.
  - `호너의 메소드` 를 이용하려면 결과에 소수를 곱하는 과정을 추가해야 한다.
    - 37과 같은 소수를 곱하면 충돌을 피할 수 있다.
    - 아래 예제 코드에서 betterHash 함수에 이를 적용하였고, 그 결과값에 충돌 없이 모두 출력됨을 확인할 수 있다.

```js
function HashTable() {
  this.table = new Array(137);
  this.simpleHash = simpleHash;
  this.betterHash = betterHash;
  this.showDistro = showDistro;
  this.put = put;
  //this.get = get;
}

//충돌을 피하지 못한 단순한 해시 함수
function simpleHash(data) {
  let total = 0;
  for (let i = 0; i < data.length; ++i) {
    total += data.charCodeAt(i);
  }
  console.log('Hash value: ' + data + '->' + total);
  return total % this.table.length;
}

//호너의 메소드를 적용하여 개선된 해시 함수
function betterHash(string) {
  const H = 37; //소수
  let total = 0;
  for (let i = 0; i < string.length; ++i) {
    total += H * total + string.charCodeAt(i); //결과에 소수를 곱하는 과정 추가
  }
  console.log('Hash value: ' + string + '->' + total);
  total = total % this.table.length;
  return parseInt(total, 10);
}

function put(data) {
  let pos = this.betterHash(data);
  this.table[pos] = data;
}

function showDistro() {
  let n = 0;
  for (let i = 0; i < this.table.length; ++i) {
    if (this.table[i] != undefined) {
      console.log(i + ':' + this.table[i]);
    }
  }
}

let someNames = [
  'Raymond',
  'Clayton',
  'Marco',
  'Poky',
  'Jisoo',
  'Jinnie',
  'Millie',
  'Dotori',
];
let hTable = new HashTable();
for (let i = 0; i < someNames.length; ++i) {
  hTable.put(someNames[i]);
}

hTable.showDistro();
```

```
//output
Hash value: Raymond->254841041852
Hash value: Clayton->210499205408
Hash value: Marco->166046545
Hash value: Poky->4554231
Hash value: Jisoo->160232013
Hash value: Jinnie->6088540563
Hash value: Millie->6326133435
Hash value: Dotori->5625971393
22:Raymond
58:Clayton
63:Millie
77:Poky
79:Marco
85:Dotori
101:Jisoo
126:Jinnie
```

### 2-3. 정수 키 해싱

- 정수 키 해싱시에도 충돌이 일어나면서 모든 데이터를 저장하는데 실패할 수 있다.
- 배열 크기를 조절해 이 문제가 해결되는지 확인하거나, 아니면 앞서 문자열 키 해싱 시 살펴본 betterHash() 함수를 호출하도록 put() 함수를 고칠 수 있다. 또는 소수의 크기를 높일 수도 있다.

```js
function HashTable() {
  this.table = new Array(137);
  this.simpleHash = simpleHash;
  this.betterHash = betterHash;
  this.showDistro = showDistro;
  this.put = put;
  //this.get = get;
}
// HashTable 가져온다.

function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function getStuData(arr) {
  for (let i = 0; i < arr.length; ++i) {
    let num = '';
    for (let j = 0; j <= 9; ++j) {
      num += Math.floor(Math.random() * 10);
    }
    num += getRandomInt(50, 100);
    arr[i] = num;
  }
}

const numStudents = 10;
const arrSize = 97;
const idLen = 9;
const students = new Array(numStudents);
getStuData(students);

for (let i = 0; i < students.length; i++) {
  console.log(students[i].substring(0, 8) + ' ' + students[i].substring(9));
}

const 정수테이블 = new HashTable();
for (let i = 0; i < students.length; i++) {
  정수테이블.put(students[i]);
}
정수테이블.showDistro();
```

### 2-4. 해시 테이블에 데이터를 저장하거나 데이터 가져오기

- put과 get 매서드 변경

```js
function HashTable() {
  this.table = new Array(137);
  this.betterHash = betterHash;
  this.showDistro = showDistro;
  this.put = put;
  this.get = get;
}

//호너의 메소드를 적용하여 개선된 해시 함수
function betterHash(string) {
  const H = 117; //소수
  let total = 0;
  for (let i = 0; i < string.length; ++i) {
    total += H * total + string.charCodeAt(i); //결과에 소수를 곱하는 과정 추가
  }
  console.log('Hash value: ' + string + '->' + total);
  total = total % this.table.length;
  return parseInt(total, 10);
}

// put() 함수는 키를 해시한 다음 해시 함수의 계산 결과로 나온 위치를 이용해 테이블에 데이터를 저장한다.
function put(key, data) {
  this.table[this.betterHash(key)] = data;
}

// get() 함수는 다시 키를 해시해서 데이터가 어느 위치에 저장되어 있는지 계산한 다음, 테이블에서 데이터를 가져와야 한다.
function get(key) {
  return this.table[this.betterHash(key)];
}

function showDistro() {
  let n = 0;
  for (let i = 0; i < this.table.length; ++i) {
    if (this.table[i] != undefined) {
      console.log(i + ':' + this.table[i]);
    }
  }
}

const hTable = new HashTable();
hTable.put('대한민국', '서울');
hTable.put('미국', '워싱턴');
hTable.put('일본', '도쿄');

console.log(hTable.get('미국'));
hTable.showDistro();
```

```
//output
Hash value: 대한민국->76056550277
Hash value: 미국->5722557
Hash value: 일본->6074400
Hash value: 미국->5722557
워싱턴
40:서울
67:워싱턴
94:도쿄
```

## 3. 충돌처리

- 해시 함수에서 두 개 이상의 값을 계산한 결과가 같을 때 충돌이 일어난다.
- 해시 알고리즘에서 고려해야 할 두 번째 사항은 바로 모든 키가 해시 테이블에 저장될 수 있게 충돌을 처리하는 부분이다. `분리된 체인`, `선형 조사`라는 두 가지 충돌 해결 방법을 확인한다.

### 3-1. 분리된 체인

- 충돌이 일어났어도 생성된 인덱스에 키를 저장할 수 있어야 하는데 배열의 요소에는 한 개의 데이터밖에 없으므로 사실상 충돌이 일어나면 어떤 것도 저장할 수 없게 된다.
- `분리된 체인 기법`에서는 두 키의 해시 결과가 같을 때 각 키는 두 번째 배열의 서로 다른 장소에 저장된다.
  - 해시된 키를 저장할 배열을 만든 다음 해시 테이블의 각 배열 요소에 빈 배열을 할당하는 방법으로 분리된 체인을 구현할 수 있다. 그러면 `이차원 배열`이 생성된다.

```js
//위 코드에서 수정,추가된 부분
function showDistro() {
  let n = 0;
  for (let i = 0; i < this.table.length; ++i) {
    if (this.table[i][0] != undefined) {
      console.log(i + ':' + this.table[i]);
    }
  }
}

//두 번재 배열(체인)을 만드는 buildChains 함수
hTable.buildChains();
function buildChains() {
  for (let i = 0; i < this.table.length; ++i) {
    this.table[i] = new Array();
  }
}
```
